My Developer Notes

Differences from traditional BASICs:
====================================

PRINT is a function call, not a statement (mostly because if used as an embedded scripting language there may not be anywhere to print to).

Comments use hash symbols rather than single quotes. This is partly because I wanted single quotes to have the same meaning as double quotes, as in Javacript.

REM is not supported for comments.

Statements found in some old BASICs that are not available include CLS, LOCATE, WHILE-WEND and so on.

There aren't any arrays, only hash tables, and they are indexed using [] instead of ().

DIM is not needed (and not implemented) because of the way these hash tables are implemented.

'&' is the string concatenation operator.
'~' is the not-equals operator.

Things I would lake to change (when I find time):
=================================================

The () around function parameters should be optional:
    PRINT "Hello World"
should be equivalent to
	PRINT("Hello World")
even if I only implement it at the statement level.

I need an operator for /references/. What I would like is an operator, say '@' that takes an identifier (perhaps also a number) and converts it to a string, so @ARRAY$ will be equivalent to "ARRAY$". 

It is useful, because then a call to 
	DATA("ARRAY$", "Alice", "Bob", "Carol")
can be rewritten as
	DATA(@ARRAY$, "Alice", "Bob", "Carol")
and it will be clear that the first parameter is a reference to a variable called ARRAY$ (even though nothing changed under the hood).

The VAL(x$) and STR$(x) built in functions are probably no longer necessary now that we're weakly typed.

ToDo Built-In Functions:
========================

Ideas for built-in functions that may be useful go in this section.

Replace$(str$, find, repl) - Replaces occurances of 'find' with 'repl' in str

GSUB$() - Like Awk's gsub() function (instead of replace$() above)

Speaking of Awk, how about a function AWK(line$, [delim$]) that takes line$ and splits it into columns in the _C[i], so that a Musl script can do some of the same work as Awk. It returns the number of columns found in the line.

IIF(expr, a, b) and IIF$(expr, a$, b$)

PUSH() and POP() functions that store variables inside some internal stack temporarily (useful for GOSUBs, because they can emulate local variables). These would benefit if the language was dynamically/weakly typed because as it stands one would need a POP() and POP$() function.

I'd also like to have a feature to dump all the variables somewhere for debugging Musl programs. It should be an API function and a Built-in function.

If I make the language dynamically typed, then the DATA() function can also store the length in a "length" field. In other words, a call like
	DATA(@ARRAY$, "Alice", "Bob", "Carol")
will result in ARRAY$["length"] being 3, in addition to its existing functionality (the Awk() function I proposed above should behave the same way wrt. _C["length"]). 
